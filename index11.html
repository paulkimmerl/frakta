<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Mandelbulb mit 12 dynamischen Spotlights</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html, body { margin:0; padding:0; background:#111; overflow:hidden; height:100%; width:100%; touch-action:none; user-select:none; }
canvas { display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

// --- Mobiloptimierung: devicePixelRatio ber체cksichtigen ---
function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    gl.viewport(0,0,canvas.width,canvas.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const vertexShaderSource = `attribute vec3 position; void main(){ gl_Position = vec4(position,1.0); }`;

const fragmentShaderSource = `
precision highp float; // highp f체r Mobilger채te

uniform vec2 resolution;
uniform vec3 camPos;
uniform vec3 camTarget;
uniform float shaderTime;

// --- alle deine Shaderfunktionen bleiben unver채ndert ---
float hash(vec3 p){ p = fract(p*0.3183099 + vec3(0.1,0.2,0.3)); p *= 17.0; return fract(p.x*p.y*p.z*(p.x+p.y+p.z)); }
float noise(vec3 p){ vec3 i=floor(p); vec3 f=fract(p); f=f*f*(3.0-2.0*f);
  float n=mix(mix(mix(hash(i),hash(i+vec3(1,0,0)),f.x),
                  mix(hash(i+vec3(0,1,0)),hash(i+vec3(1,1,0)),f.x),f.y),
              mix(mix(hash(i+vec3(0,0,1)),hash(i+vec3(1,0,1)),f.x),
                  mix(hash(i+vec3(0,1,1)),hash(i+vec3(1,1,1)),f.x),f.y),f.z);
  return n;
}
float fbm(vec3 p){ float f=0.0; float amp=0.5; float freq=0.25; for(int i=0;i<2;i++){ f+=amp*noise(p*freq); freq*=2.0; amp*=0.5; } return f; }

float mandelbulbDE(vec3 pos,float power,vec3 offset,float t){
  vec3 z=pos; float dr=1.0; float r=0.0;
  for(int i=0;i<8;i++){
    r=length(z); if(r>2.0) break;
    float theta=acos(z.z/r); float phi=atan(z.y,z.x);
    dr=pow(r,power-1.0)*power*dr+1.0;
    float zr=pow(r,power); theta*=power; phi*=power;
    float tSlow = t*0.004;  
    float tMed  = t*0.008;   
    z=zr*vec3(
      sin(theta+2.0*sin(tSlow))*cos(phi+2.0*sin(tMed)),
      sin(theta+2.0*sin(tMed))*sin(phi+2.0*sin(tSlow)),
      cos(theta+2.0*sin(tSlow))
    ) + pos + offset;
  }
  return 0.5*log(r)*r/dr;
}

vec3 getNormal(vec3 p,float power,vec3 offset,float t){
  float eps=0.002; float d=mandelbulbDE(p,power,offset,t);
  return normalize(vec3(
    mandelbulbDE(p+vec3(eps,0,0),power,offset,t)-d,
    mandelbulbDE(p+vec3(0,eps,0),power,offset,t)-d,
    mandelbulbDE(p+vec3(0,0,eps),power,offset,t)-d
  ));
}

float raymarch(vec3 ro,vec3 rd,float power,vec3 offset,float t){
  float d,tTotal=0.0;
  for(int i=0;i<40;i++){
    vec3 p=ro+rd*tTotal;
    d=mandelbulbDE(p,power,offset,t);
    if(d<0.003) return tTotal;
    if(tTotal>20.0) break;
    tTotal+=d;
  }
  return -1.0;
}

void main(){
  vec3 col=vec3(0.0);
  vec2 uv = (gl_FragCoord.xy)/resolution.xy*2.0-1.0;
  uv.x *= resolution.x/resolution.y;

  vec3 forward=normalize(camTarget-camPos);
  vec3 right=normalize(cross(vec3(0,1,0),forward));
  vec3 up=cross(forward,right);
  vec3 rd=normalize(uv.x*right+uv.y*up+forward);
  vec3 ro=camPos;

  float tAnim = shaderTime;
  float power=7.0+0.2*sin(tAnim*0.03);
  vec3 offset=vec3(
    0.2*sin(tAnim*0.015),
    0.2*sin(tAnim*0.018+1.0),
    0.2*sin(tAnim*0.017+2.5)
  );
  offset += 0.02*fbm(ro*0.5 + tAnim*0.005);

  float dist=raymarch(ro,rd,power,offset,tAnim);
  if(dist>0.0){
    vec3 pos=ro+rd*dist;
    vec3 normal=getNormal(pos,power,offset,tAnim);

    // Original Licht
    vec3 lightDir1 = normalize(vec3(sin(tAnim*0.03),1.0,cos(tAnim*0.03)));
    float lightNoise = fbm(pos*3.0+tAnim*0.03);
    lightNoise = smoothstep(0.4,1.0,lightNoise);
    float diff1 = clamp(dot(normal,lightDir1),0.0,1.0)*lightNoise;
    float spec1 = pow(max(dot(reflect(-lightDir1,normal),-rd),0.0),32.0)*lightNoise*0.2;
    col += vec3(1.0)*diff1 + vec3(1.0)*spec1;

    // 12 dynamische Spotlights
    for(int i=0;i<12;i++){
        float angleOffset = float(i) * 0.523598776;
        float speedFactor = 0.7 + 0.6*hash(vec3(float(i),0.0,0.0));
        float angleSpeed = tAnim * 0.3 * speedFactor + angleOffset;
        float radiusLight = 1.5;
        float heightOffset = 0.3 + 0.5*sin(tAnim*0.2*speedFactor + float(i));
        vec3 spotlightPos = vec3(
            radiusLight * cos(angleSpeed),
            heightOffset,
            radiusLight * sin(angleSpeed)
        );
        vec3 spotDir = normalize(spotlightPos - pos);
        float distToSpot = length(spotlightPos - pos);
        float spotRange = 1.0;
        float spotAtten = smoothstep(spotRange, 0.0, distToSpot);
        float spotFocus = clamp(dot(normal, spotDir), 0.0, 1.0);
        spotFocus = pow(spotFocus,32.0);
        col += vec3(0.7) * spotAtten * spotFocus;
    }
  }

  col=col/(col+vec3(1.0));
  col=pow(col,vec3(0.9));
  gl_FragColor=vec4(col,1.0);
}
`;

// Shader Setup
function compileShader(type,source){
  const shader=gl.createShader(type);
  gl.shaderSource(shader,source);
  gl.compileShader(shader);
  if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(shader)); return null; }
  return shader;
}
const vertexShader=compileShader(gl.VERTEX_SHADER,vertexShaderSource);
const fragmentShader=compileShader(gl.FRAGMENT_SHADER,fragmentShaderSource);
const program=gl.createProgram();
gl.attachShader(program,vertexShader);
gl.attachShader(program,fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

const posLoc=gl.getAttribLocation(program,"position");
const resLoc=gl.getUniformLocation(program,"resolution");
const camPosLoc=gl.getUniformLocation(program,"camPos");
const camTargetLoc=gl.getUniformLocation(program,"camTarget");
const timeLoc=gl.getUniformLocation(program,"shaderTime");

const buffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,0,1,-1,0,-1,1,0,-1,1,0,1,-1,0,1,1,0]),gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0);

let azimuth=0,elevation=0.4,radius=1.2;
let targetAzimuth=0,targetElevation=0.4,targetRadius=1.2;
let isDragging=false,lastX=0,lastY=0,lastDist=null;
const MIN_RADIUS = 0.3;
const MAX_RADIUS = 3.5;
function damp(current,target,lambda,dt){ return current + (target-current)*(1.0-Math.exp(-lambda*dt)); }

// Maus & Touch
canvas.addEventListener("mousedown", e=>{isDragging=true; lastX=e.clientX; lastY=e.clientY;});
canvas.addEventListener("mousemove", e=>{if(isDragging){let dx=e.clientX-lastX; let dy=e.clientY-lastY; targetAzimuth+=dx*0.002; targetElevation+=dy*0.002; lastX=e.clientX; lastY=e.clientY;}});
window.addEventListener("mouseup", ()=>isDragging=false);
canvas.addEventListener("touchstart", e=>{
  if(e.touches.length===1){isDragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;}
  else if(e.touches.length===2){let dx=e.touches[0].clientX-e.touches[1].clientX; let dy=e.touches[0].clientY-e.touches[1].clientY; lastDist=Math.sqrt(dx*dx+dy*dy);}
});
canvas.addEventListener("touchmove", e=>{
  if(e.touches.length===1 && isDragging){let dx=e.touches[0].clientX-lastX; let dy=e.touches[0].clientY-lastY; targetAzimuth+=dx*0.002; targetElevation+=dy*0.002; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;}
  else if(e.touches.length===2){
    let dx = e.touches[0].clientX - e.touches[1].clientX;
    let dy = e.touches[0].clientY - e.touches[1].clientY;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if(lastDist!==null){
      targetRadius -= (dist - lastDist)*0.01;
      targetRadius = Math.max(MIN_RADIUS, Math.min(MAX_RADIUS, targetRadius));
    }
    lastDist = dist;
  }
},{passive:false});
window.addEventListener("touchend", ()=>{lastDist=null; isDragging=false;});
window.addEventListener("wheel", e=>{targetRadius += e.deltaY*0.01; targetRadius = Math.max(MIN_RADIUS, Math.min(MAX_RADIUS, targetRadius));});

let shaderTime = 0.0;
let lastTime = performance.now()/1000;
function render(now){
  now *= 0.001;
  const dt = now - lastTime;
  lastTime = now;
  
  shaderTime += dt*0.6;

  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform2f(resLoc,canvas.width,canvas.height);
  gl.uniform1f(timeLoc, shaderTime);

  azimuth = damp(azimuth, targetAzimuth, 8.0, dt);
  elevation = damp(elevation, targetElevation, 8.0, dt);
  radius = damp(radius, targetRadius, 8.0, dt);

  targetAzimuth += 0.00002;

  const camX = radius*Math.sin(azimuth)*Math.cos(elevation);
  const camY = radius*Math.sin(elevation);
  const camZ = radius*Math.cos(azimuth)*Math.cos(elevation);
  gl.uniform3f(camPosLoc,camX,camY,camZ);
  gl.uniform3f(camTargetLoc,0,0,0);

  gl.drawArrays(gl.TRIANGLES,0,6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
