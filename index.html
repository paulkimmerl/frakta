<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Raymarching Sphere Minimal</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; background:black; height:100%; width:100%;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
  const canvas = document.getElementById('glcanvas');

  // Canvas Größe auf Fenster setzen
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', () => {
    resize();
    gl.viewport(0, 0, canvas.width, canvas.height);
  });
  resize();

  const gl = canvas.getContext('webgl');
  if (!gl) {
    alert("WebGL wird nicht unterstützt");
  }

  // Shader Quellen
  const vertexShaderSource = `
    attribute vec3 position;
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision highp float;
    uniform vec2 resolution;

    // Distance function für Kugel
    float sphereSDF(vec3 p, float r) {
      return length(p) - r;
    }

    // Raymarching Funktion
    float raymarch(vec3 ro, vec3 rd) {
      float t = 0.0;
      for(int i=0; i<64; i++) {
        vec3 pos = ro + t * rd;
        float dist = sphereSDF(pos, 1.0);
        if(dist < 0.001) return t;
        if(t > 20.0) break;
        t += dist;
      }
      return -1.0;
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
      uv.x *= resolution.x / resolution.y;

      vec3 ro = vec3(0., 0., 3.);
      vec3 rd = normalize(vec3(uv, -1.5));

      float dist = raymarch(ro, rd);

      vec3 col = vec3(0.0);

      if(dist > 0.0) {
        col = vec3(1.0); // weiße Kugel
      }

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  // Shader bauen
  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader Fehler:", gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  }

  const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Programm Fehler:", gl.getProgramInfoLog(program));
  }

  gl.useProgram(program);

  // Attribute
  const posAttribLoc = gl.getAttribLocation(program, 'position');
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  // Vollbild-Quad (2 Dreiecke)
  const positions = new Float32Array([
    -1, -1, 0,
     1, -1, 0,
    -1,  1, 0,
    -1,  1, 0,
     1, -1, 0,
     1,  1, 0,
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(posAttribLoc);
  gl.vertexAttribPointer(posAttribLoc, 3, gl.FLOAT, false, 0, 0);

  // Uniform
  const resolutionUniformLoc = gl.getUniformLocation(program, 'resolution');

  // Clear Color & Viewport
  gl.clearColor(0, 0, 0, 1);
  gl.viewport(0, 0, canvas.width, canvas.height);

  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform2f(resolutionUniformLoc, canvas.width, canvas.height);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
</script>
</body>
</html>
