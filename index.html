<!DOCTYPE html><html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Mandelbulb + Sponge Hybrid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL wird nicht unterst√ºtzt");canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height);

const vertexShaderSource = attribute vec3 position; void main() { gl_Position = vec4(position, 1.0); };

const fragmentShaderSource = ` precision highp float; uniform vec2 resolution; uniform float time;

float mandelbulbDE(vec3 pos) { vec3 z = pos; float dr = 1.0; float r = 0.0; float power = 8.0 + sin(time * 0.0003) * 4.0; for(int i = 0; i < 8; i++) { r = length(z); if (r > 2.0) break; float theta = acos(z.z / r); float phi = atan(z.y, z.x); dr =  pow(r, power - 1.0) * power * dr + 1.0; float zr = pow(r, power); theta *= power; phi *= power; z = zr * vec3( sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta) ) + pos; } return 0.5 * log(r) * r / dr; }

float spongeDE(vec3 p) { p = abs(p); return length(max(p - 1.0, 0.0)) - 0.1; }

float hybridScene(vec3 p) { float d1 = mandelbulbDE(p); float d2 = spongeDE(p * 1.5 + vec3(sin(time*0.0002), 0.0, 0.0)); return max(d1, -d2); // intersection for carving holes }

float raymarch(vec3 ro, vec3 rd) { float t = 0.0; for (int i = 0; i < 128; i++) { vec3 p = ro + rd * t; float d = hybridScene(p); if (d < 0.001) return t; if (t > 20.0) break; t += d * 0.8; } return -1.0; }

vec3 getNormal(vec3 p) { float eps = 0.001; float d = hybridScene(p); return normalize(vec3( hybridScene(p + vec3(eps, 0, 0)) - d, hybridScene(p + vec3(0, eps, 0)) - d, hybridScene(p + vec3(0, 0, eps)) - d )); }

void main() { vec2 uv = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0; uv.x *= resolution.x / resolution.y;

vec3 ro = vec3(3.0 * sin(time * 0.0001), 1.5, 3.0 * cos(time * 0.0001));
vec3 ta = vec3(0.0);
vec3 fw = normalize(ta - ro);
vec3 rt = normalize(cross(vec3(0.0, 1.0, 0.0), fw));
vec3 up = cross(fw, rt);
vec3 rd = normalize(uv.x * rt + uv.y * up + fw);

float t = raymarch(ro, rd);
vec3 col = vec3(0.0);
if (t > 0.0) {
  vec3 pos = ro + rd * t;
  vec3 normal = getNormal(pos);
  vec3 lightDir = normalize(vec3(1.0, 0.8, 0.5));
  float diff = clamp(dot(normal, lightDir), 0.0, 1.0);
  col = vec3(diff);
}

gl_FragColor = vec4(col, 1.0);

} `;

function compileShader(type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shader)); return null; } return shader; }

const vs = compileShader(gl.VERTEX_SHADER, vertexShaderSource); const fs = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource); const program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program); gl.useProgram(program);

const positionLoc = gl.getAttribLocation(program, "position"); const resolutionLoc = gl.getUniformLocation(program, "resolution"); const timeLoc = gl.getUniformLocation(program, "time");

const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1, -1, 0, 1, -1, 0, -1,  1, 0, -1,  1, 0, 1, -1, 0, 1,  1, 0 ]), gl.STATIC_DRAW); gl.enableVertexAttribArray(positionLoc); gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

function render(time) { gl.viewport(0, 0, canvas.width, canvas.height); gl.uniform2f(resolutionLoc, canvas.width, canvas.height); gl.uniform1f(timeLoc, time); gl.drawArrays(gl.TRIANGLES, 0, 6); requestAnimationFrame(render); } requestAnimationFrame(render); </script>

</body>
</html>
