<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Animiertes morphendes Mandelbulb (Graustufen, AO, OrbitControl)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; background:black; height:100%; width:100%;
    user-select: none;
    cursor: grab;
    touch-action: none;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }
  body:active {
    cursor: grabbing;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
  const canvas = document.getElementById('glcanvas');

  function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
  }
  window.addEventListener('resize', () => {
    resize();
    gl.viewport(0, 0, canvas.width, canvas.height);
  });
  resize();

  const gl = canvas.getContext('webgl');
  if (!gl) alert("WebGL wird nicht unterst√ºtzt");

  const vertexShaderSource = `
    attribute vec3 position;
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision highp float;
    uniform vec2 resolution;
    uniform vec3 camPos;
    uniform vec3 camTarget;
    uniform float time;

    // Mandelbulb DE mit dynamischem power (Morphing)
    float mandelbulbDE(vec3 pos, float power) {
      vec3 z = pos;
      float dr = 1.0;
      float r = 0.0;
      const int ITER = 12;
      for(int i = 0; i < ITER; i++) {
        r = length(z);
        if (r > 2.0) break;

        float theta = acos(z.z / r);
        float phi = atan(z.y, z.x);
        dr =  pow(r, power - 1.0) * power * dr + 1.0;

        float zr = pow(r, power);
        theta = theta * power;
        phi = phi * power;

        z = zr * vec3(
          sin(theta) * cos(phi),
          sin(theta) * sin(phi),
          cos(theta)
        ) + pos;
      }
      return 0.5 * log(r) * r / dr;
    }

    // Normal Approximation
    vec3 getNormal(vec3 p, float power) {
      float eps = 0.001;
      float d = mandelbulbDE(p, power);
      return normalize(vec3(
        mandelbulbDE(p + vec3(eps, 0, 0), power) - d,
        mandelbulbDE(p + vec3(0, eps, 0), power) - d,
        mandelbulbDE(p + vec3(0, 0, eps), power) - d
      ));
    }

    // Ambient Occlusion Approximation
    float calcAO(vec3 p, vec3 n, float power) {
      float ao = 0.0;
      float sca = 1.0;
      for(int i = 1; i <= 5; i++) {
        float hr = float(i) * 0.02;
        float d = mandelbulbDE(p + n * hr, power);
        ao += (hr - d) * sca;
        sca *= 0.7;
      }
      return clamp(1.0 - ao, 0.0, 1.0);
    }

    // Raymarching
    float raymarch(vec3 ro, vec3 rd, float power) {
      float t = 0.0;
      for(int i = 0; i < 150; i++) {
        vec3 p = ro + t * rd;
        float dist = mandelbulbDE(p, power);
        if(dist < 0.001) return t;
        if(t > 20.0) break;
        t += dist;
      }
      return -1.0;
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
      uv.x *= resolution.x / resolution.y;

      vec3 forward = normalize(camTarget - camPos);
      vec3 right = normalize(cross(vec3(0.0,1.0,0.0), forward));
      vec3 up = cross(forward, right);

      vec3 rd = normalize(uv.x * right + uv.y * up + forward);
      vec3 ro = camPos;

      // Animierter Power-Wert morphend zwischen 6.0 und 10.0 mit Sinus (Langsam)
      float power = 8.0 + 2.0 * sin(time * 0.5);

      float dist = raymarch(ro, rd, power);

      vec3 col = vec3(0.0);
      if(dist > 0.0) {
        vec3 pos = ro + rd * dist;
        vec3 normal = getNormal(pos, power);
        vec3 lightDir = normalize(vec3(0.0, 1.0, 1.0));

        float diff = clamp(dot(normal, lightDir), 0.0, 1.0);
        float ao = calcAO(pos, normal, power);

        // Graustufen mit AO-Modulation, etwas Gamma-Korrektur (0.8)
        float gray = pow(diff * ao, 0.8);
        col = vec3(gray);
      }

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader Fehler:", gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  }

  const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Programm Fehler:", gl.getProgramInfoLog(program));
  }

  gl.useProgram(program);

  const posAttribLoc = gl.getAttribLocation(program, 'position');
  const resolutionUniformLoc = gl.getUniformLocation(program, 'resolution');
  const camPosUniformLoc = gl.getUniformLocation(program, 'camPos');
  const camTargetUniformLoc = gl.getUniformLocation(program, 'camTarget');
  const timeUniformLoc = gl.getUniformLocation(program, 'time');

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  const positions = new Float32Array([
    -1, -1, 0,
     1, -1, 0,
    -1,  1, 0,
    -1,  1, 0,
     1, -1, 0,
     1,  1, 0,
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(posAttribLoc);
  gl.vertexAttribPointer(posAttribLoc, 3, gl.FLOAT, false, 0, 0);

  function resizeCanvas() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Orbit Control Variablen
  let azimuth = 0;
  let elevation = 0.4;
  const radius = 3.5;
  let isDragging = false;
  let lastX, lastY;

  function pointerDown(x, y) {
    isDragging = true;
    lastX = x;
    lastY = y;
  }
  function pointerMove(x, y) {
    if(!isDragging) return;
    const dx = (x - lastX) * 0.005;
    const dy = (y - lastY) * 0.005;
    azimuth += dx;
    elevation += dy;
    elevation = Math.min(Math.max(elevation, 0.1), Math.PI / 2 - 0.1);
    lastX = x;
    lastY = y;
  }
  function pointerUp() {
    isDragging = false;
  }

  // Maus Events
  canvas.addEventListener('mousedown', e => pointerDown(e.clientX, e.clientY));
  window.addEventListener('mouseup', pointerUp);
  window.addEventListener('mousemove', e => pointerMove(e.clientX, e.clientY));

  // Touch Events
  canvas.addEventListener('touchstart', e => {
    if(e.touches.length == 1) {
      e.preventDefault();
      pointerDown(e.touches[0].clientX, e.touches[0].clientY);
    }
  }, {passive:false});
  canvas.addEventListener('touchmove', e => {
    if(e.touches.length == 1) {
      e.preventDefault();
      pointerMove(e.touches[0].clientX, e.touches[0].clientY);
    }
  }, {passive:false});
  window.addEventListener('touchend', e => {
    if(e.touches.length === 0) pointerUp();
  });

  // Automatische Rotation wenn nicht draggen (sehr langsam)
  const autoRotateSpeed = 0.03;

  function getCameraPosition(time) {
    if(isDragging) {
      return [
        radius * Math.sin(azimuth) * Math.cos(elevation),
        radius * Math.sin(elevation),
        radius * Math.cos(azimuth) * Math.cos(elevation)
      ];
    } else {
      let az = azimuth + time * 0.001 * autoRotateSpeed;
      return [
        radius * Math.sin(az) * Math.cos(elevation),
        radius * Math.sin(elevation),
        radius * Math.cos(az) * Math.cos(elevation)
      ];
    }
  }

  function render(time=0) {
    gl.clear(gl
