<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Mandelbulb Animation</title>
<style>html,body,canvas{margin:0;padding:0;width:100%;height:100%;display:block;background:#000;}</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const c=document.getElementById("c"),gl=c.getContext("webgl");
if(!gl)alert("WebGL nicht verf√ºgbar");
function resize(){c.width=window.innerWidth;c.height=window.innerHeight;gl.viewport(0,0,c.width,c.height);}
resize();
window.onresize=resize;

const vert=`attribute vec3 p;void main(){gl_Position=vec4(p,1.);}`;
const frag=`
precision highp float;
uniform vec2 res; uniform float time; uniform vec3 camPos, camTarget;

float mandelbulbDE(vec3 pos,float power,float ox,float oy,float oz){
  vec3 z=pos; float dr=1.; float r=0.;
  for(int i=0;i<10;i++){
    r=length(z);
    if(r>2.)break;
    float theta=acos(z.z/r),phi=atan(z.y,z.x);
    dr=pow(r,power-1.)*power*dr+1.;
    float zr=pow(r,power);
    theta*=power; phi*=power;
    z=zr*vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta))+pos+vec3(ox,oy,oz);
  }
  return 0.5*log(r)*r/dr;
}

vec3 getNormal(vec3 p,float power,float ox,float oy,float oz){
  float e=0.001,d=mandelbulbDE(p,power,ox,oy,oz);
  return normalize(vec3(
    mandelbulbDE(p+vec3(e,0,0),power,ox,oy,oz)-d,
    mandelbulbDE(p+vec3(0,e,0),power,ox,oy,oz)-d,
    mandelbulbDE(p+vec3(0,0,e),power,ox,oy,oz)-d
  ));
}

float raymarch(vec3 ro,vec3 rd,float power,float ox,float oy,float oz){
  float t=0.;
  for(int i=0;i<100;i++){
    vec3 p=ro+t*rd;
    float d=mandelbulbDE(p,power,ox,oy,oz);
    if(d<0.001)return t;
    if(t>20.)break;
    t+=d;
  }
  return -1.;
}

void main(){
  vec2 uv=(gl_FragCoord.xy/res)*2.-1.;
  uv.x*=res.x/res.y;

  vec3 forward=normalize(camTarget-camPos);
  vec3 right=normalize(cross(vec3(0,1,0),forward));
  vec3 up=cross(forward,right);

  vec3 rd=normalize(uv.x*right+uv.y*up+forward);
  vec3 ro=camPos;

  float power=mix(6.,20.,0.5+0.5*sin(time*0.03));
  float ox=0.5*sin(time*0.02);
  float oy=0.5*cos(time*0.015);
  float oz=0.5*sin(time*0.01+1.);

  float dist=raymarch(ro,rd,power,ox,oy,oz);
  vec3 col=vec3(0);
  if(dist>0.){
    vec3 pos=ro+rd*dist;
    vec3 n=getNormal(pos,power,ox,oy,oz);
    vec3 light=normalize(vec3(sin(time*0.3),cos(time*0.4),sin(time*0.2)));
    float diff=clamp(dot(n,light),0.,1.);
    col=vec3(diff);
  }
  gl_FragColor=vec4(col,1.);
}`;

function compile(t,s){
  let sh=gl.createShader(t);
  gl.shaderSource(sh,s);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS))console.error(gl.getShaderInfoLog(sh));
  return sh;
}

const program=gl.createProgram();
gl.attachShader(program,compile(gl.VERTEX_SHADER,vert));
gl.attachShader(program,compile(gl.FRAGMENT_SHADER,frag));
gl.linkProgram(program);
gl.useProgram(program);

const posLoc=gl.getAttribLocation(program,"p");
const resLoc=gl.getUniformLocation(program,"res");
const timeLoc=gl.getUniformLocation(program,"time");
const camPosLoc=gl.getUniformLocation(program,"camPos");
const camTargetLoc=gl.getUniformLocation(program,"camTarget");

const buffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,0,1,-1,0,-1,1,0,-1,1,0,1,-1,0,1,1,0]),gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0);

// Orbit Control
let az=0.5,el=0.3,r=0.1,isDown=false,lastX=0,lastY=0;
c.onmousedown=e=>{isDown=true;lastX=e.clientX;lastY=e.clientY;}
c.onmouseup=()=>isDown=false;
c.onmousemove=e=>{
  if(!isDown)return;
  az+= (e.clientX-lastX)*0.005;
  el+= (e.clientY-lastY)*0.005;
  el=Math.min(Math.max(el,0.05,Math.min(Math.PI/2-0.05,el)));
  lastX=e.clientX; lastY=e.clientY;
}
c.onwheel=e=>{
  r+=e.deltaY*0.001;
  r=Math.min(Math.max(r,0.05),10);
}

function render(t=0){
  gl.viewport(0,0,c.width,c.height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform2f(resLoc,c.width,c.height);
  gl.uniform1f(timeLoc,t*0.001);

  let cx=r*Math.sin(az)*Math.cos(el);
  let cy=r*Math.sin(el);
  let cz=r*Math.cos(az)*Math.cos(el);
  gl.uniform3f(camPosLoc,cx,cy,cz);
  gl.uniform3f(camTargetLoc,0,0,0);

  gl.drawArrays(gl.TRIANGLES,0,6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
