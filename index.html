<!DOCTYPE html>  
<html lang="de">  
<head>  
  <meta charset="UTF-8" />  
  <title>3D Mandelbulb Fraktal SW mit sanfter FBM Animation</title>  
  <meta name="viewport" content="width=device-width, initial-scale=1" />  
  <style>  
    html, body {  
      margin: 0;  
      padding: 0;  
      background: black;  
      overflow: hidden;  
      height: 100%;  
      width: 100%;  
      touch-action: none;  
      user-select: none;  
    }  
    canvas {  
      display: block;  
      width: 100vw;  
      height: 100vh;  
    }  
  </style>  
</head>  
<body>  
<canvas id="glcanvas"></canvas>  
<script>  
const canvas = document.getElementById("glcanvas");  
const gl = canvas.getContext("webgl");  
if (!gl) alert("WebGL wird nicht unterst체tzt");  
  
canvas.width = window.innerWidth;  
canvas.height = window.innerHeight;  
gl.viewport(0, 0, canvas.width, canvas.height);  
  
// Vertex Shader: einfache Positionierung  
const vertexShaderSource = `  
  attribute vec3 position;  
  void main() {  
    gl_Position = vec4(position, 1.0);  
  }  
`;  
  
// Fragment Shader mit Mandelbulb + sanfter FBM Noise + Animation zweier Parameter  
const fragmentShaderSource = `  
  precision highp float;  
  
  uniform vec2 resolution;  
  uniform vec3 camPos;  
  uniform vec3 camTarget;  
  uniform float time;  
  
  // 3D rotation helper  
  mat3 rotationY(float angle) {  
    float c = cos(angle);  
    float s = sin(angle);  
    return mat3(  
      c, 0.0, -s,  
      0.0, 1.0, 0.0,  
      s, 0.0, c  
    );  
  }  
  
  // Simplex Noise implementation adapted for GLSL -  
  // to generate smooth noise for FBM  
  // Source: https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl  
  // (shortened and adapted)  
  
  vec4 mod289(vec4 x) {  
    return x - floor(x * (1.0 / 289.0)) * 289.0;  
  }  
  vec3 mod289(vec3 x) {  
    return x - floor(x * (1.0 / 289.0)) * 289.0;  
  }  
  vec4 permute(vec4 x) {  
    return mod289(((x*34.0)+1.0)*x);  
  }  
  float snoise(vec3 v) {  
    const vec2  C = vec2(1.0/6.0, 1.0/3.0);  
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);  
  
    // First corner  
    vec3 i  = floor(v + dot(v, C.yyy) );  
    vec3 x0 = v - i + dot(i, C.xxx);  
  
    // Other corners  
    vec3 g = step(x0.yzx, x0.xyz);  
    vec3 l = 1.0 - g;  
    vec3 i1 = min( g.xyz, l.zxy );  
    vec3 i2 = max( g.xyz, l.zxy );  
  
    // x0, x1, x2, x3  
    vec3 x1 = x0 - i1 + C.xxx;  
    vec3 x2 = x0 - i2 + C.yyy;  
    vec3 x3 = x0 - D.yyy;  
  
    // Permutations  
    i = mod289(i);   
    vec4 p = permute( permute( permute(  
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))  
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))  
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));  
  
    // Gradients: 7x7x6 points over a cube, mapped onto a 3D gradient  
    float n_ = 1.0/7.0; // 1/7  
    vec3  ns = n_ * D.wyz - D.xzx;  
  
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  // mod 7*7  
  
    vec4 x_ = floor(j * ns.z);  
    vec4 y_ = floor(j - 7.0 * x_ );  
  
    vec4 x = x_ *ns.x + ns.y;  
    vec4 y = y_ *ns.x + ns.y;  
    vec4 h = 1.0 - abs(x) - abs(y);  
  
    vec4 b0 = vec4( x.xy, y.xy );  
    vec4 b1 = vec4( x.zw, y.zw );  
  
    vec4 s0 = floor(b0)*2.0 + 1.0;  
    vec4 s1 = floor(b1)*2.0 + 1.0;  
    vec4 sh = -step(h, vec4(0.0));  
  
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;  
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;  
  
    vec3 p0 = vec3(a0.xy,h.x);  
    vec3 p1 = vec3(a0.zw,h.y);  
    vec3 p2 = vec3(a1.xy,h.z);  
    vec3 p3 = vec3(a1.zw,h.w);  
  
    // Normalise gradients  
    vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));  
    p0 *= norm.x;  
    p1 *= norm.y;  
    p2 *= norm.z;  
    p3 *= norm.w;  
  
    // Mix contributions from the four corners  
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);  
    m = m * m;  
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );  
  }  
  
  // Fractal Brownian Motion with 3 octaves  
  float fbm(vec3 p) {  
    float f = 0.0;  
    float amp = 0.5;  
    float freq = 1.0;  
    for(int i=0; i<3; i++) {  
      f += amp * snoise(p * freq);  
      freq *= 2.0;  
      amp *= 0.5;  
    }  
    return f;  
  }  
  
  // Mandelbulb distance estimator with subtle noise modulation  
  float mandelbulbDE(vec3 pos, float offsetAnim, float morphAnim) {  
    vec3 z = pos;  
    float dr = 1.0;  
    float r = 0.0;  
    const int ITER = 8;  
    float power = 8.0 + morphAnim * 0.5; // morphAnim leicht variieren power  
    for(int i = 0; i < ITER; i++) {  
      r = length(z);  
      if (r > 2.0) break;  
  
      // Spherical coords  
      float theta = acos(z.z / r);  
      float phi = atan(z.y, z.x);  
  
      dr =  pow(r, power - 1.0) * power * dr + 1.0;  
      float zr = pow(r, power);  
  
      theta *= power;  
      phi *= power;  
  
      // Basis Mandelbulb transform  
      z = zr * vec3(  
        sin(theta)*cos(phi),  
        sin(theta)*sin(phi),  
        cos(theta)  
      ) + pos;  
  
      // Sanfte Verschiebung mit animiertem Offset + FBM Noise  
      float noiseVal = fbm(z * 1.5 + vec3(offsetAnim * 0.5));  
      z += noiseVal * 0.1;  
  
      // Zus채tzlich Offset animieren (verschiebt leicht)  
      z += vec3(sin(offsetAnim * 3.0) * 0.05, cos(offsetAnim * 2.0) * 0.05, sin(offsetAnim) * 0.05);  
    }  
  
    // Klassischer Mandelbulb DE mit log zur Gl채ttung  
    return 0.5 * log(r) * r / dr;  
  }  
  
  // Normalenberechnung 체ber Differenzen  
  vec3 getNormal(vec3 p, float offsetAnim, float morphAnim) {  
    float eps = 0.001;  
    float d = mandelbulbDE(p, offsetAnim, morphAnim);  
    return normalize(vec3(  
      mandelbulbDE(p + vec3(eps, 0, 0), offsetAnim, morphAnim) - d,  
      mandelbulbDE(p + vec3(0, eps, 0), offsetAnim, morphAnim) - d,  
      mandelbulbDE(p + vec3(0, 0, eps), offsetAnim, morphAnim) - d  
    ));  
  }  
  
  // Raymarching  
  float raymarch(vec3 ro, vec3 rd, float offsetAnim, float morphAnim) {  
    float t = 0.0;  
    for(int i = 0; i < 100; i++) {  
      vec3 p = ro + t * rd;  
      float dist = mandelbulbDE(p,
