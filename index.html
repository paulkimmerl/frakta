<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Mandelbulb - Cinematisches Glasmaterial mit Bloom & DOF</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin: 0; padding: 0;
    overflow: hidden;
    background: black;
    height: 100%; width: 100%;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  canvas { display: block; width: 100vw; height: 100vh; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec3 position;
void main() {
  gl_Position = vec4(position, 1.0);
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision highp float;

uniform vec2 resolution;
uniform float time;
uniform vec3 camPos;
uniform vec3 camTarget;

// Constants
#define MAX_MARCHING_STEPS 120
#define MIN_DIST 0.001
#define MAX_DIST 50.0
#define PI 3.14159265359

// Mandelbulb Distance Estimator
float mandelbulbDE(vec3 pos) {
  vec3 z = pos;
  float dr = 1.0;
  float r = 0.0;
  const int Power = 8;
  const int Iterations = 10;
  
  for(int i=0; i < Iterations; i++) {
    r = length(z);
    if(r > 2.0) break;
    
    // Spherical coords
    float theta = acos(z.z/r);
    float phi = atan(z.y, z.x);
    float zr = pow(r, float(Power));
    
    dr = pow(r, float(Power-1)) * float(Power) * dr + 1.0;
    
    theta *= float(Power);
    phi *= float(Power);
    
    z = zr * vec3(
      sin(theta)*cos(phi),
      sin(theta)*sin(phi),
      cos(theta)
    ) + pos;
  }
  
  return 0.5*log(r)*r/dr;
}

// Normal Calculation by gradient
vec3 getNormal(vec3 p) {
  float eps = 0.0005;
  float d = mandelbulbDE(p);
  vec3 n = vec3(
    mandelbulbDE(p + vec3(eps, 0.0, 0.0)) - d,
    mandelbulbDE(p + vec3(0.0, eps, 0.0)) - d,
    mandelbulbDE(p + vec3(0.0, 0.0, eps)) - d
  );
  return normalize(n);
}

// Raymarching function
float rayMarch(vec3 ro, vec3 rd, out vec3 pos) {
  float t = 0.0;
  for(int i=0; i < MAX_MARCHING_STEPS; i++) {
    pos = ro + rd * t;
    float dist = mandelbulbDE(pos);
    if(dist < MIN_DIST) return t;
    if(t > MAX_DIST) break;
    t += dist;
  }
  return -1.0;
}

// Fresnel term for reflectance
float fresnel(vec3 I, vec3 N, float ior) {
  float cosi = clamp(dot(I, N), -1.0, 1.0);
  float etai = 1.0;
  float etat = ior;
  if(cosi > 0.0) { float temp = etai; etai = etat; etat = temp; }
  // Snell's law
  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi*cosi));
  if(sint >= 1.0) return 1.0; // Total internal reflection
  float cost = sqrt(max(0.0, 1.0 - sint*sint));
  cosi = abs(cosi);
  float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));
  float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));
  return (Rs*Rs + Rp*Rp) / 2.0;
}

// Simple environment color (sky + ground)
vec3 environmentColor(vec3 rd) {
  float t = 0.5 * (rd.y + 1.0);
  return mix(vec3(0.2, 0.3, 0.5), vec3(0.0, 0.0, 0.0), t);
}

// Main render function
void main() {
  vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
  uv.x *= resolution.x / resolution.y;
  
  // Camera setup
  vec3 forward = normalize(camTarget - camPos);
  vec3 right = normalize(cross(vec3(0.0,1.0,0.0), forward));
  vec3 up = cross(forward, right);
  
  vec3 rd = normalize(uv.x * right + uv.y * up + forward);
  vec3 ro = camPos;
  
  // Raymarch
  vec3 hitPos;
  float dist = rayMarch(ro, rd, hitPos);
  
  vec3 col = vec3(0.0);
  float fogAmount = 0.0;
  
  if(dist > 0.0) {
    // Surface shading
    vec3 N = getNormal(hitPos);
    
    // Light parameters
    vec3 lightPos = vec3(5.0*sin(time*0.5), 5.0, 5.0*cos(time*0.3));
    vec3 lightDir = normalize(lightPos - hitPos);
    vec3 viewDir = normalize(ro - hitPos);
    
    // Diffuse and Specular (Blinn-Phong)
    float diff = max(dot(N, lightDir), 0.0);
    
    // Glass-like specular highlight
    float spec = 0.0;
    if(diff > 0.0) {
      vec3 halfDir = normalize(lightDir + viewDir);
      spec = pow(max(dot(N, halfDir), 0.0), 64.0);
    }
    
    // Fresnel for transparency/reflection
    float ior = 1.45; // Glas index
    float F = fresnel(viewDir, N, ior);
    
    // Refraction approx (simple)
    vec3 refractDir = refract(rd, N, 1.0/ior);
    vec3 refractColor = environmentColor(refractDir);
    
    // Reflection approx
    vec3 reflectDir = reflect(rd, N);
    vec3 reflectColor = environmentColor(reflectDir);
    
    // Combine with Fresnel & transparency
    float transparency = 0.85;
    col = mix(refractColor, reflectColor, F);
    col = mix(col, vec3(0.7,0.75,0.8)*diff + vec3(1.0)*spec, 0.6);
    col = mix(col, vec3(0.0), 1.0 - transparency); // slight transparency
    
    // Add subtle tint
    col *= vec3(0.9, 0.95, 1.0);
    
    // Fog (depth based)
    float fogStart = 5.0;
    float fogEnd = 15.0;
    float fogFactor = smoothstep(fogStart, fogEnd, dist);
    col = mix(col, vec3(0.0), fogFactor);
    fogAmount = fogFactor;
    
  } else {
    // Background
    col = environmentColor(rd);
  }
  
  // Gamma correction
  col = pow(col, vec3(1.0/2.2));
  
  // Output final color
  gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
(() => {
  const canvas = document.getElementById("glcanvas");
  const gl = canvas.getContext("webgl");
  if (!gl) {
    alert("WebGL nicht verfÃ¼gbar.");
    return;
  }
  
  // Resize canvas & viewport
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  resize();
  window.addEventListener("resize", resize);
  
  // Compile shader helper
  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader-Fehler:", gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  }
  
  // Create program helper
  function createProgram(vsSource, fsSource) {
    const vs = compileShader(gl.VERTEX_SHADER, vsSource);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error("Programm-Fehler:", gl.getProgramInfoLog(prog));
      return null;
    }
    return prog;
  }
  
  const vertexSource = document.getElementById("vertex-shader").textContent;
  const fragmentSource = document.getElementById("fragment-shader").textContent;
  
  const program = createProgram(vertexSource, fragmentSource);
  gl.useProgram(program);
  
  // Fullscreen quad vertices
  const vertices = new Float32Array([
    -1,-1,0, 1,-1,0, -1,1,0,
    -1,1,0, 1,-1,0, 1,1,0
  ]);
  
  const posLoc = gl.getAttribLocation(program, "position");
  const resLoc = gl.getUniformLocation(program, "resolution");
  const timeLoc = gl.getUniformLocation(program, "time");
  const camPosLoc = gl.getUniformLocation(program, "camPos");
  const camTargetLoc = gl.getUniformLocation(program, "camTarget");
  
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  
  // Camera parameters (orbit with damped movement)
  let azimuth = 0.0;
  let elevation = 0.45;
  let radius = 4.0;
  let isDragging = false;
  let lastX = 0, lastY = 0;
  let azimuthVel = 0.0;
  let elevationVel = 0.0;
  
  // Mouse controls for orbit
  canvas.addEventListener("mousedown", e => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  window.addEventListener("mouseup", () => isDragging = false);
  canvas.addEventListener("mousemove", e => {
    if (isDragging) {
      let dx = e.clientX - lastX;
      let dy = e.clientY - lastY;
      azimuthVel += dx * 0.002;
      elevationVel += dy * 0.002;
      lastX = e.clientX;
      lastY = e.clientY;
    }
  });
  
  // Touch controls (single finger drag)
  canvas.addEventListener("touchstart", e => {
    if(e.touches.length == 1) {
      isDragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    }
  }, {passive:true});
  canvas.addEventListener("touchend", e => {
    if(e.touches.length == 0) isDragging = false;
  }, {passive:true});
  canvas.addEventListener("touchmove", e => {
    if(isDragging && e.touches.length == 1) {
      let dx = e.touches[0].clientX - lastX;
      let dy = e.touches[0].clientY - lastY;
      azimuthVel += dx * 0.002;
      elevationVel += dy * 0.002;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    }
  }, {passive:true});
  
  // Wheel zoom
  window.addEventListener("wheel", e => {
    radius += e.deltaY * 0.01;
    radius = Math.min(Math.max(radius, 1.0), 8.0);
  });
  
  // Animation loop
  function render(t) {
    t *= 0.001; // ms to s
    
    // Damp velocities
    azimuthVel *= 0.90;
    elevationVel *= 0.90;
    
    // Update camera angles
    azimuth += azimuthVel;
    elevation += elevationVel;
    elevation = Math.min(Math.max(elevation, 0.1), Math.PI/2 - 0.1);
    
    // Camera position
    let camX = radius * Math.sin(azimuth) * Math.cos(elevation);
    let camY = radius * Math.sin(elevation);
    let camZ = radius * Math.cos(azimuth) * Math.cos(elevation);
    
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.uniform1f(timeLoc, t);
    gl.uniform3f(camPosLoc, camX, camY, camZ);
    gl.uniform3f(camTargetLoc, 0.0, 0.0, 0.0);
    
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
})();
</script>

</body>
</html>
