<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Mandelbulb mit Touch-Zoom</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: black;
      overflow: hidden;
      height: 100%; width: 100%;
      touch-action: none;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
// ... gleich wie zuvor bis ZOOM Abschnitt ...

const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, canvas.width, canvas.height);

// ... Shader setup wie gehabt (keine Änderung am Fraktal/FBM/Animation) ...

// === Zoom & Kamera ===
let azimuth = 0;
let elevation = 0.5;
let radius = 4.0; // Kameradistanz
let isDragging = false;
let lastX = 0, lastY = 0;
let lastTouchDist = 0;

canvas.addEventListener("mousedown", e => {
  isDragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
canvas.addEventListener("mousemove", e => {
  if (isDragging) {
    azimuth += (e.clientX - lastX) * 0.005;
    elevation += (e.clientY - lastY) * 0.005;
    elevation = Math.max(0.05, Math.min(Math.PI / 2 - 0.05, elevation));
    lastX = e.clientX;
    lastY = e.clientY;
  }
});
window.addEventListener("mouseup", () => isDragging = false);

// Maus-Zoom
canvas.addEventListener("wheel", e => {
  radius += e.deltaY * 0.01;
  radius = Math.min(Math.max(radius, 1.5), 20.0);
});

// === Touch Unterstützung ===
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    isDragging = true;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    lastTouchDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
  }
});
canvas.addEventListener("touchmove", e => {
  if (isDragging && e.touches.length === 1) {
    azimuth += (e.touches[0].clientX - lastX) * 0.005;
    elevation += (e.touches[0].clientY - lastY) * 0.005;
    elevation = Math.max(0.05, Math.min(Math.PI / 2 - 0.05, elevation));
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    const newDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const delta = newDist - lastTouchDist;
    radius -= delta * 0.01;
    radius = Math.min(Math.max(radius, 1.5), 20.0);
    lastTouchDist = newDist;
  }
});
canvas.addEventListener("touchend", () => {
  isDragging = false;
  lastTouchDist = 0;
});

// === Render ===
function render(now) {
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.uniform2f(resLoc, canvas.width, canvas.height);
  gl.uniform1f(timeLoc, now * 0.001);

  // Kamera-Position berechnen
  const camX = radius * Math.sin(azimuth) * Math.cos(elevation);
  const camY = radius * Math.sin(elevation);
  const camZ = radius * Math.cos(azimuth) * Math.cos(elevation);
  gl.uniform3f(camPosLoc, camX, camY, camZ);
  gl.uniform3f(camTargetLoc, 0, 0, 0);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
