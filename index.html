<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Mandelbulb mit Glas-Effekt, Bloom & Fog</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin: 0; padding: 0;
    overflow: hidden;
    background: black;
    height: 100%;
    width: 100%;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
(() => {
  const canvas = document.getElementById("glcanvas");
  const gl = canvas.getContext("webgl");
  if (!gl) {
    alert("WebGL wird von deinem Browser nicht unterst√ºtzt!");
    return;
  }
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);

  // --- Vertex Shader ---
  const vertexShaderSource = `
    attribute vec3 position;
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `;

  // --- Fragment Shader mit Glas-Material, Bloom & Fog ---
  const fragmentShaderSource = `
    precision highp float;
    uniform vec2 resolution;
    uniform float time;
    uniform vec3 camPos;
    uniform vec3 camTarget;

    // Hash & Noise Funktionen
    float hash(vec3 p) {
      p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
      p *= 17.0;
      return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
    }

    float noise(vec3 p){
      vec3 i = floor(p);
      vec3 f = fract(p);
      f = f*f*(3.0-2.0*f);
      float n = mix(mix(mix(hash(i), hash(i+vec3(1,0,0)),f.x),
                        mix(hash(i+vec3(0,1,0)), hash(i+vec3(1,1,0)),f.x),f.y),
                    mix(mix(hash(i+vec3(0,0,1)), hash(i+vec3(1,0,1)),f.x),
                        mix(hash(i+vec3(0,1,1)), hash(i+vec3(1,1,1)),f.x),f.y),f.z);
      return n;
    }

    float fbm(vec3 p) {
      float f = 0.0;
      float amp = 0.5;
      float freq = 0.3;
      for(int i = 0; i < 4; i++) {
        f += amp * noise(p * freq);
        freq *= 2.0;
        amp *= 0.5;
      }
      return f;
    }

    // Mandelbulb Distance Estimator
    float mandelbulbDE(vec3 pos, float power, vec3 offset) {
      vec3 z = pos;
      float dr = 1.0;
      float r = 0.0;
      const int ITER = 8;
      for(int i = 0; i < ITER; i++) {
        r = length(z);
        if (r > 2.0) break;
        float theta = acos(z.z / r);
        float phi = atan(z.y, z.x);
        dr = pow(r, power - 1.0) * power * dr + 1.0;
        float zr = pow(r, power);
        theta *= power;
        phi *= power;
        z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)) + pos + offset;
      }
      return 0.5 * log(r) * r / dr;
    }

    vec3 getNormal(vec3 p, float power, vec3 offset) {
      float eps = 0.001;
      float d = mandelbulbDE(p, power, offset);
      return normalize(vec3(
        mandelbulbDE(p + vec3(eps, 0, 0), power, offset) - d,
        mandelbulbDE(p + vec3(0, eps, 0), power, offset) - d,
        mandelbulbDE(p + vec3(0, 0, eps), power, offset) - d
      ));
    }

    float raymarch(vec3 ro, vec3 rd, float power, vec3 offset) {
      float t = 0.0;
      for(int i = 0; i < 100; i++) {
        vec3 p = ro + t * rd;
        float dist = mandelbulbDE(p, power, offset);
        if(dist < 0.001) return t;
        if(t > 20.0) break;
        t += dist;
      }
      return -1.0;
    }

    float fresnel(vec3 I, vec3 N, float ior) {
      float cosi = clamp(dot(I, N), -1.0, 1.0);
      float etai = 1.0, etat = ior;
      if (cosi > 0.0) { float temp = etai; etai = etat; etat = temp; }
      float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));
      if (sint >= 1.0) return 1.0;
      float cost = sqrt(max(0.0, 1.0 - sint * sint));
      cosi = abs(cosi);
      float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));
      float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));
      return (Rs * Rs + Rp * Rp) / 2.0;
    }

    vec3 refractVec(vec3 I, vec3 N, float eta) {
      float cosi = dot(-I, N);
      float cost2 = 1.0 - eta * eta * (1.0 - cosi * cosi);
      return eta * I + (eta * cosi - sqrt(abs(cost2))) * N;
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
      uv.x *= resolution.x / resolution.y;

      vec3 forward = normalize(camTarget - camPos);
      vec3 right = normalize(cross(vec3(0,1,0), forward));
      vec3 up = cross(forward, right);
      vec3 rd = normalize(uv.x * right + uv.y * up + forward);
      vec3 ro = camPos;

      float power = 7.0 + 0.4 * sin(time * 0.1);
      vec3 offset = vec3(
        0.3 * sin(time * 0.07),
        0.3 * sin(time * 0.08 + 1.57),
        0.3 * sin(time * 0.09 + 3.14)
      );
      float noiseVal = 0.05 * fbm(ro * 0.5 + time * 0.05);
      offset += noiseVal;

      float dist = raymarch(ro, rd, power, offset);

      vec3 col = vec3(0.0);

      if(dist > 0.0) {
        vec3 pos = ro + rd * dist;
        vec3 normal = getNormal(pos, power, offset);

        float ior = 1.5;
        float fresnelTerm = fresnel(rd, normal, ior);

        vec3 refractDir = refractVec(rd, normal, 1.0 / ior);
        float refractDist = raymarch(pos + refractDir * 0.01, refractDir, power, offset);

        vec3 refractColor = vec3(0.0);
        if(refractDist > 0.0) {
          vec3 refractPos = pos + refractDir * refractDist;
          vec3 refractNormal = getNormal(refractPos, power, offset);
          vec3 lightDir = normalize(vec3(sin(time * 0.15), cos(time * 0.3), sin(time * 0.1)));
          float diffRefract = clamp(dot(refractNormal, lightDir), 0.0, 1.0);
          refractColor = vec3(0.6, 0.7, 0.8) * diffRefract * 0.8;
        }

        vec3 lightDir = normalize(vec3(sin(time * 0.25), cos(time * 0.4), sin(time * 0.15)));
        float diff = clamp(dot(normal, lightDir), 0.0, 1.0);

        vec3 baseColor = vec3(0.8, 0.85, 0.9);

        col = mix(refractColor, baseColor * diff, fresnelTerm);

        float fogAmount = smoothstep(10.0, 20.0, dist);
        vec3 fogColor = vec3(0.05, 0.07, 0.1);
        col = mix(col, fogColor, fogAmount);

        float bloom = pow(diff, 4.0);
        col += bloom * vec3(0.4, 0.45, 0.5);
      }

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  // Shader compilation helper
  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader Fehler:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.bindAttribLocation(program, 0, "position");
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Programm Link Fehler:", gl.getProgramInfoLog(program));
    return;
  }

  gl.useProgram(program);

  // Vollbild-Quad (2 Dreiecke)
  const vertices = new Float32Array([
    -1, -1, 0,
     1, -1, 0,
    -1,  1, 0,
    -1,  1, 0,
     1, -1, 0,
     1,  1, 0,
  ]);
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  const positionLoc = 0;
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

  // Uniform Locations
  const resolutionLoc = gl.getUniformLocation(program, "resolution");
  const timeLoc = gl.getUniformLocation(program, "time");
  const camPosLoc = gl.getUniformLocation(program, "camPos");
  const camTargetLoc = gl.getUniformLocation(program, "camTarget");

  // Kamera Orbit Control Variablen
  let yaw = 0;
  let pitch = 0;
  let targetYaw = 0;
  let targetPitch = 0;
  const radius = 5;

  let dragging = false;
  let lastX = 0;
  let lastY = 0;

  canvas.addEventListener("mousedown", e => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  window.addEventListener("mouseup", () => dragging = false);
  window.addEventListener("mousemove", e => {
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    targetYaw += dx * 0.005;
    targetPitch += dy * 0.005;
    targetPitch = Math.min(Math.max(targetPitch, -Math.PI / 2 + 0.1), Math.PI / 2 - 0.1);
  });

  function animate(t) {
    t *= 0.001; // Sekunden

    // Kamera sanft animieren
    yaw += (targetYaw - yaw) * 0.1;
    pitch += (targetPitch - pitch) * 0.1;

    const camX = radius * Math.cos(pitch) * Math.sin(yaw);
    const camY = radius * Math.sin(pitch);
    const camZ = radius * Math.cos(pitch) * Math.cos(yaw);

    const camPos = [camX, camY, camZ];
    const camTarget = [0, 0, 0];

    gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
    gl.uniform1f(timeLoc, t);
    gl.uniform3fv(camPosLoc, camPos);
    gl.uniform3fv(camTargetLoc, camTarget);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // Resize-Handler
  window.addEventListener("resize", () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  });
})();
</script>
</body>
</html>
